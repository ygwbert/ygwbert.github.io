{"posts":[{"title":"2 bugs example","content":"创建VC业务选择端口 SDH交叉容量配置 ","link":"https://ygwbert.github.io/post/2-bugs-example/"},{"title":"C++ tips","content":"1、vector存储使用内存池，对于vector对象的访问时通过迭代器来访问的，因此降低访问效率 2、构造函数初始化列表与普通构造函数的区别: 构造函数初始化列表用于在显式初始化类成员。在平常的使用构造函数创建对象时，如果对象中将另一个对象作为成员，那么在调用构造函数之前，编译器会用成员对象的默认构造函数进行初始化。如果不想让编译器用默认的构造函数进行初始化，就要使用构造函数初始化列表来显式规定成员对象的初始化形式。 构造函数进行的操作是，将成员先初始化，再用给定值赋值给初始化后的成员，而构造函数初始化列表则是直接对成员进行初始化，两者之间的区别跟下面两种创建变量的方式区别类似： //在创建的时候直接初始化，相当于构造函数初始化列表 int x = 3; //先创建x，再赋值给x，相当于普通构造函数的初始化方式 int x; x = 3; 3、带参数宏定义时记得该打括号的都打上括号 ","link":"https://ygwbert.github.io/post/c-tips/"},{"title":"版本管理Git指南","content":"git使用指南 安卓平台框架层次总结 ","link":"https://ygwbert.github.io/post/ban-ben-guan-li-git-zhi-nan/"},{"title":"安卓指纹源码 part review","content":"到HAL层的调用 ","link":"https://ygwbert.github.io/post/an-zhuo-zhi-wen-yuan-ma-part-review/"},{"title":"Lniux命令相关","content":"一、 Ls -l后，显示文件属性字段，每一行都为该文件的属性字段描述，每一列均有意义 属主代表自己，属组代表与自己同组的其他用户，与自己不同组的用户就是“其他用户” 537、28、9的意义视文件类型而不同 1、若该文件不是目录文件，则数字意义表示该文件硬链接数，如上图zoneinfo文件的数字1表示该文件只有一个硬链接，即inode link count的计数为1，若计数大于等于1，则表是该文件有多个硬链接，当删除文件时，只会在inode link count计数上减一，硬链接就相当于给文件起别名，硬链接不能跨文件系统 2、若该文件是目录文件，该数字表示该目录所含子目录数（linux每一个目录文件默认包含两个子目录“.表示自己”、“..”表示上级目录） 圆框代表该文件所占字节数（为什么都显示0个字节） 二、 source命令：读取filename中的命令，文件脚本中&amp;&amp;表示执行完上一个才能执行下一个 ls -l : ls -al :会显示隐藏文件 linux用户、群组、其他人： 用户主目录为/home/，/home/Lyinggang这个就是我的，其他人可以浏览，其他权限由自己来设置 群组：同公司的人拉入群组中查看 其他人：除了用户、群组其他的都是其他人 还有一个root，它可以访问查看任何文件 ","link":"https://ygwbert.github.io/post/lniux-ming-ling-xiang-guan/"},{"title":"电子模组中的某些概念","content":"增益：电子学中，输出信号功率与输入信号功率之比 SPI：串行外设接口，SPI速率，调整的应该是数据线传输数据的速度 Dump_info：转储文件就是进程某一时刻的快照，包含调用堆栈等信息，方便查取 抓取转储文件 Firmware：固件，写入EROM、EEPROM中的程序，固件程序最底层，和硬件打交道 SPI：串行外设接口，用于单片机中读写FLASH中的内容， SPI(Serial Peripheral Interface--串行外设接口)总线系统是一种同步串行外设接口，它可以使MCU与各种外围设备以串行方式进行通信以交换信息。SPI总线可直接与各个厂家生产的多种标准外围器件相连，包括FLASHRAM、网络控制器、LCD显示驱动器、A/D转换器和MCU等。该接口一般使用4条线：串行时钟线（SCLK）、主机输入/从机输出数据线MISO、主机输出/从机输入数据线MOSI和低电平有效的从机选择线NSS。 ","link":"https://ygwbert.github.io/post/dian-zi-mo-zu-zhong-de-mou-xie-gai-nian/"},{"title":"指纹识别与防伪","content":"1、指纹识别特征点 一级特征：指纹形态大致为三类：螺旋、拱型、 二级特征：分叉点、端点（end）、 三级特征：要求高分辨率，汗腺分布 2、真假手指区别： 真手指脊线会因为汗腺、汗等特征而断断续续，不会很连贯，假手指脊线连贯，因此沿脊线的频率，真手指高频（有灰度剧烈变化），假手指低频 如果真手指按压力度大、导致脊线全部连在一起，没有断掉的地方，可能会被当假手指 同理，假手指按压力度不均，导致脊线有高频量，可能会被认假 活体检测之后再实行比对策略， 比对策略之后再实行活体检测，可能匹配和不匹配的指纹进行不同的活体检测策略 FAR：把本该拒绝的指纹接受，认假 FAR与FRR成反比，若待识别的指纹与模板的相似度为一个数值，相似度大于给定阈值则比对成功，提高该阈值，意味着比对门槛上升，需要更相似才能比对成功，FRR随该阈值提升而提升，FAR随该阈值提升而降低，阈值越高，越不容易匹配成功，FA现象减少，因此画FAR与FRR曲线，交点处就是最佳阈值，交点即极小值处 3、sensorhub：传感器控制中心 1）、融合来自各个传感器设备的数据，从而更好地实现一些功能，这些功能可能需要多个传感器的数据 2）、主控CPU休眠时，运行在sensorhub上的RTOS可以完成对传感器的实时控制，降低主控CPU 的功耗 3）计算SNR： 电容式或者光学指纹的采图原理是，当手指按压在传感器位置上时，指纹的谷脊之间会产生不同的信号，例如电容式指纹，谷与脊之间在传感器上感应到的电容值不一样，这个差值越大，将使得收集的信号越准确，转换成的指纹图越清晰，因此，该差值可作为信号强度值 噪声强度值：连续采集多帧图片，当数量多了以后，可认为信号强度值足够小，噪声强度值足够大，eg：连续采集七帧图像，遍历七帧图像中间区域，七张图像内对应像素点位置的最大灰度值减去最小灰度值，这个差值为噪声值 SNR比值 = 信号强度值/噪声强度值 ","link":"https://ygwbert.github.io/post/zhi-wen-shi-bie-yu-fang-wei/"},{"title":"傅里叶变化","content":"一、平行于X轴的直线是一个周期无限长的简谐波，周期无限长，频率为0， 频域图像，就是频谱 频谱纵坐标为振幅，横坐标为频率 光谱就是频谱 时域谱纵坐标也为振幅，横坐标为时间 相位谱纵坐标为相位，横坐标为频率 时域的微分积分操作在频域可变为加减法 相位谱 距离频率方向的频率轴的最近的波峰到频率轴的平面投影距离是时间差，它不是相位差，用时间差除以周期乘以2π，才等于相位差 每个简谐波如此得到的时间差直接除以所在频率的简谐波的周期，得到每个简谐波的相位谱 相位谱谱值定义域为(-pi，pi]，因为相位是周期变化的，0和pi的波就是实现了上下翻转，-pi和pi的波是一样的 二、在信号学当中，一维傅里叶变换目的是为了将无规律的信号变换为有规律的信号的组合 ","link":"https://ygwbert.github.io/post/fu-li-xie-bian-hua/"},{"title":"算法代码规范格式","content":"工作中总结的一些编程规范，都是身边人和自己踩过的坑与血 一、函数 1、有效代码行数不超过50行 2、入参一定要检查合法性，使用参数的函数对参数进行检查，透传参数不用检查 3、函数一般返回状态码，结果用指针返回，所以 调用函数必须处理每一个状态码 4、高扇入，不超过7的扇出，函数高可用性，中等调用其他函数 5、不变参数用const修饰，函数参数不超过7个，超过合并为结构体or拆分函数 6、源文件范围内所有函数除了要被外部可见，统统加static 1.256这个数需要变成宏或者const int（作用域只在这个函数），因为可能灰度级数从256变成2或者16等其他数字。 2.return函数状态，函数结果用指针传出。 7、源文件范围内的函数，不会被外部文件调用的函数，一律用static修饰 二、宏与常量 用宏一定要记得加括号， #define SQUARE(a) ((a)*(a)) 尽量用const，少用宏 三、内存操作 1、避免使用危险函数sprintf /vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。 2、存储类型关键字声明 Auto:自动存储变量关键字，在内存中开辟一个临时变量，所有局部变量的默认存储类型 register：早期C编译器不会自动优化，需要手动指定，被修饰的变量被送进寄存器 static：存储在静态数据区 对全局变量： 对局部变量： extern：多个文件共享，可被外部文件共享的变量和函数 四、变量 1、变量功能单一，函数返回值既是状态又是实际意义的值，这一点应该是不可以的 2、把数据结构、结构体当类使用，使其代表一个具体的事物 ","link":"https://ygwbert.github.io/post/suan-fa-dai-ma-gui-fan-ge-shi/"},{"title":"将PC安卓源代码烧录到手机上的步骤","content":"1、刷安卓操作系统，可以只选择downloadonly选项，与其他选项一样 2、刷系统时，只需要连接USB数据线，由于连接USB数据线时手机会进入不断重启状态，且连接不稳定，因此应先在flash_tool中点下download键预备，当手机和主机连接成功时就会开始烧录，不会陷入重启 3、刷完系统让手机开机只需要连接电源线让手机开机即可（也只会开一段时间就关闭），不需要连接USB数据线 4、板子上这些按钮中有reset钮 一键下载电路导致的不断重启问题？？？具体原理是怎样 ","link":"https://ygwbert.github.io/post/jiang-pc-an-zhuo-yuan-dai-ma-shao-lu-dao-shou-ji-shang-de-bu-zou/"},{"title":"《图像处理基础》（刚萨雷斯）笔记Part2 二值化~归一化","content":"一、二值化 1、均值二值化，全局均值二值化，局部均值二值化 2、利用直方图两个最大极大值之间的最低点作为阈值 3、OSTU二值化法 最大类间方差法 1）、首先算出图像灰度直方图，归一化灰度直方图 2）、遍历法搜索出最合适的阈值i： 循环i 从0到255，计算灰度从0到i的像素点所占的比例为w0，其平均灰度为u0（利用没有归一化的直方图来计算），此为后景（因为更偏黑），剩下的从i+1到255的像素点所占比例为w1，平均灰度为u1，此为前景（灰度偏白） 计算前景与后景之间的类间方差w0w1(u0-u1)^2，记下来 循环，选出最大类间方差的阈值i 二、直方图操作 1、灰度mapping 映射原图灰度级到另一个灰度级 gamma校正目的是为了更符合人眼观察特点 2、直方图均衡化 目的是为了使图片的灰度分布不要集中在某一个部分，展宽过于集中的灰度值，归并过于少的灰度值 3、AHE,CLAHE 自适应直方图归一化，会放大噪声值 对比度限制直方图归一化，限制了噪声值的归一 原理之后再看 三、图像插值 用在对图像进行扩充、形变、旋转操作 四、锐化 1 Unsharp masking 非锐化掩膜，见图像1 2、拉普拉斯算子锐化 其实就是将边缘检测算子的计算结果再加回到原图上，见图像1 3、Laplacian of Gaussian 先用空域高斯滤波去除高斯噪声，然后再用拉普拉斯算子，见图像1 五、图像归一化 Log算子 高斯滤波和拉普拉斯算子可以加在一起，如何将两种矩阵对一个像素点所做出的变换合成为一个？ 这就是锐化 归一化就是灰度mapping到【0，1】的灰度级 六、图像掩膜 mask为一幅二值图，与原图相乘，提取感兴趣区域 主要作用： ①提取感兴趣区,用预先制作的感兴趣区掩模与待处理图像相乘,得到感兴趣区图像,感兴趣区内图像值保持不变,而区外图像值都为0。 ②屏蔽作用,用掩模对图像上某些区域作屏蔽,使其不参加处理或不参加处理参数的计算,或仅对屏蔽区作处理或统计。 ③结构特征提取,用相似性变量或图像匹配方法检测和提取图像中与掩模相似的结构特征。 如何提取？？？ ④特殊形状图像的制作。用选定的图像、图形或物体,对待处理的图像(全部或局部)进行遮挡,来控制图像处理的区域或处理过程。用于覆盖的特定图像或物体称为掩模或模板。 七、空间相关和空间卷积的区别： 卷积核有没有转过180度 卷积的边界填充方法：零填充或者用边界值填充 八、图像去除均值的好处： 图像减均值滤波后的图像，是得到的锐化边缘的意思 图像去图像均值的 好处，去除共同特征，留下个体差异部分 九、贝塞尔曲线，通过控制点制造出曲线， P0 P1，两个控制点，得出一条直线，P = t( P0) + (1-t)P1 ","link":"https://ygwbert.github.io/post/lesslesstu-xiang-chu-li-ji-chu-greatergreater-gang-sa-lei-si-bi-ji-part2-er-zhi-hua-~gui-yi-hua/"},{"title":"《图像处理基础》（刚萨雷斯）笔记Part1 滤波","content":"一、滤波（空间域滤波） 1、均值滤波 平滑效果 2、高斯滤波，消除高斯噪声，可平滑高斯噪声，在频率域是否为 3、中值滤波，取中值，卷积核内的灰度值排序，取排在中间的那个，可平滑椒盐噪声 4、边缘提取， 空间域对图像求微分：对图像求微分，求导，该点的一阶微分为右边或上边的像素点灰度值减去该点灰度值，（所以一阶微分能够算出一边边缘），二阶微分为前一个加上后一个灰度值减去该点灰度值，（二阶微分双边） 1）sobel算子（对边缘定位精度不高，首先二值化是边缘更明显再进行提取） Gx，Gy，描述横向纵向梯度变化 2）roberts算子： 二阶斜对角算子，因为是二阶，所以卷积面积更小，只有四个像素，因此它能显示出更加细的边缘，三阶卷积核面积更大，所以边缘精度不高 3）Prewitt算子 本义为roberts算子的三维扩充，在计算G时，可像sobel一样取梯度的膜，即平方和开平方，也可以在Gx和Gy中选择一个最大的作为梯度值 4）Log滤波器 其他算子滤波器的融合 首先用高斯滤波器平滑图像，再用拉普拉斯算子进行边缘提取，由于拉普拉斯算子对噪声较为敏感，所以先用高斯进行平滑 5）Cannny算子 也是其他算子滤波器步骤的融合。（较为经典，最好掌握） A、先用高斯平滑，再选择一个边缘检测算子计算，高斯噪声在信号处理领域较为常见，因此它去燥综合效果最好 B、选择算子检测，一般sobel算子检测 C、非极大值抑制，由于sobel算子检测出的边缘非常粗，混杂了非边缘点进去，因此，剔除非极大值，极大值意为该点灰度值大于其八连通区域内的其他像素点灰度 D、双阈值法筛选强边缘和弱边缘，设定一个阈值T1，T2，强度大于T1的为强边缘，大于T2小于T2的为弱边缘，小于T2的不是边缘点，强边缘点直接可以作为边缘点处理，弱边缘点进一步筛选，查找它的八连通区域内是否存在强边缘点，若存在，则弱边缘点就是边缘点（这一步实际就实现了边缘连接），否则不是 实际使用中，T1：T2 = 2：1 图像处理较为重要的步骤：去噪，灰度归一化 6）拉普拉斯算子 锐化即可以用来提取边缘，对噪声较为敏感 5、其他处理手段 1）拉普拉斯锐化 拉普拉斯算子：为X方向和Y方向对该点求二阶微分的结果，最简单的 各向同性微分算子，如下所示，还可扩展为八连通的地方 【0，-1，0 【1，1，1 -1，4，-1 1，-8，1 0，-1，0】 1，1，1】 当中心系数为正时，拉普拉斯算子卷积过后，灰度突变的像素点处的值会更大更突出，灰度变化平缓的地方拉普拉斯计算过后为0，因此将原图像与拉普拉斯算子计算过后的叠加得到锐化图像 2）锐化。非锐化mask，首先平滑原图像，得到平滑后的图像，原图像减去平滑后的图像，得到一张只有灰度剧烈变化处才会有灰度值的值，这个为mask，用mask加上原图，即完成了锐化，细节处更增强 Mask(x,y) = G(x,y) - ave(G(x,y)) //均值滤波平滑 G(x,y) = G(x,y)+k*mask(x,y) 当系数k大于1时，为高提升滤波，即细节处。灰度变化比较强烈的地方会得到更大突出 6、其他概念 1）梯度图像为，▽f为梯度向量，梯度向量的膜即为梯度图像的灰度值，描述了在正交单位向量方向上的图像像素点的灰度变化 为加快计算速度，一般取绝对值的和，不做开平方运算 ","link":"https://ygwbert.github.io/post/lesslesstu-xiang-chu-li-ji-chu-greatergreater-gang-sa-lei-si-bi-ji/"},{"title":"C语言tips","content":"1、透传参数： 数据透传，底层数据透传，指底层不需要对参数进行检查或什么操作，只负责将参数传递给另一端底层，检查或其他操作由上层进行 2、strlen返回值为size_t类型，即unsigned int 3、预处理命令 预处理命令本身不是C语言的组成部分，不能被直接编译，在预处理过后就不会存在预处理命令了，之后再被编译，得到可执行目标代码 4、C语言预处理功能：宏定义、文件包含、条件编译 有参宏，相当于函数，提高效率 5、条件编译 大工程中，大部分代码类似，但小部分因为硬件版本不同需要不同的编译，使用条件编译大大增加可移植性 6、空类型指针void*只存储一个地址值，没有类型，不能直接作为右值赋值其他类型指针，需要显式转换， Int a Int *p = &amp;a; Void *s = p; //地址值赋值给空类型指针，合法 p = s；//不合法 P = (int *)s;//ok 7、#pragma para ，因参数不同而对编译器下不同命令，不同的编译器命令不一样，需要自己去看对应编译器的命令 1）#pragma once，类似于 #ifndef 宏名 #def 宏名 #ednif 2）#pragma message(&quot;要打印的消息&quot;)，在编译器执行的时候打印，不会再结果中输出 3）#pragma pack(i) 让编译器按i字节对齐，用于让结构体成员紧密排列在内存 8、跨文件共享变量方法 在同名头文件中声明这个变量，并且用extern修饰，在同名源代码文件中定义并初始化这个变量 想要调用的函数中包含该头文件，现在可直接使用 9、结构体在内存中排列更紧密的方法 #pragma pack(1) 让结构体在内存中相对于结构体首个变量按1字节对齐，节省内存，勿忘恢复字节排序值 #pragma pack() 10、 11、 12、Const char * ptr, 表示*ptr所代表的内容是const，不可更改，但是可以： 1）、重新赋值ptr改变其指向 2）、ptr所指向的内容是一个非const的变量，可以通过该变量来改变值 Const char *p = &quot;sssss&quot;; char str[] = &quot;tttttttt&quot;; p = str; 而Char* const ptr;定义一个char*类型常数指针，指针的指向不可更改，但是指向的内容可以改 13、C编程如何进行文件读取 1）、系统调用，用dos的dir函数 2）、头文件&lt;io.h&gt;中的findfirst，findnext函数，返回文件句柄 3）、头文件&lt;dirent.h&gt;中的opendir、readdir函数 14、双感叹号，!! n，非零变为0，0还是0 15、do while(0)的妙用 在宏定义中，能让要执行的语句成为一个不可分割的整体，即代码基础块，如if else语句中，可以让语句接在if后指挥执行一次，这样的代码在linux内核代码中很常见，因为可移植性好 冗余的错误处理代码，可以代替goto语句，而用do{ break; } while(0)，使得break之后跳出执行后面的错误处理代码，而不用不安全的goto 16、float类型数据运算很慢，需要用int，这就是产测流程中所有计算都为int类型的原因 ","link":"https://ygwbert.github.io/post/yi-xie-gai-nian/"},{"title":"Visual Studio Tips","content":"1、一个solution下，要跨project包含其他项目的头文件，要在设置中进行设置l附加包含目录 2、项目被设置为启动项时，这个project的里的main函数才会运行，不然不会被运行 ","link":"https://ygwbert.github.io/post/visual-studio-tips/"}]}